ltm data-group internal dstPortToLinkidDG {
    records {
        3128 { data 637559468 }
        4024 { data 637559468 }
        4025 { data 637559468 }
        4026 { data 637559468 }
        4027 { data 637559468 }
        4028 { data 637559468 }
        4029 { data 637559468 }
        7025 { data 637559468 }
        8025 { data all }
    }
    type string
}

ltm data-group internal globalHostAllowDG {
    records {
        codecloud.web.att.com { }
        www.att.net { }
        www.f5.com { }
        smtp.jessnet.net { }
    }
    type string
}

ltm data-group internal linkIDhostsDG {
    records {
        637559468 { data www.att.com,smtp.it.att.com,www.google.com,www.duckduckgo.com }
    }
    type string
}

ltm data-group internal mapPortToIPport {
    records {
        4024 { data "www.google.com|80" }
        4025 { data "www.att.com|80" }
        4026 { data "www.duckduckgo.com|80" }
        4027 { data "smtp.it.att.com|25" }
        4028 { data "smtp.it.jessnet.net|80" }
        7025 { data "smtp.jessnet.net|25" }
        8025 { data "smtp.jessnet.net|25" }
    }
    type string
}

ltm rule /Common/bastionIRule-retry {
priority 500
when RULE_INIT {
  set static::binary_min_ttl 30
  set static::binary_max_ttl 300
  set static::drop_tables 1
}

when CLIENT_ACCEPTED {
  log local0. "CLIENT_ACCEPTED (500)"
  if { !([info exists status]) || $status eq "" } {
    set status "unknown"
  }
  if { !([info exists reason]) || $reason eq "" } {
    set reason "default"
  }
  set status "allow"

  #log local0. "priority 400 client_accepted, tcp local port is [TCP::local_port]"
  # Create a variable called key which has the destination TCP port. This will serve as the lookup key into the datagroup.
  set key [TCP::local_port]
  # Create a variable called destination which has the extracted destination from the datagroup
  set destination [class match -value $key equals mapPortToIPport]
  # log local0. "Value pulled from Datagroup mapPortToIPport = [class match -value $key equals mapPortToIPport]"
  # Check to see if the response from the datagroup was empty, if so, set a variable so the other iRule can log appropriately
  # The BIG-IP datagroup does not have an entry for this port
  if { $destination eq "" } {
    set status "reject"
    set reason "Datagroup mapPortToIPport did not have an entry for port $key"
    return
  } else {
    # Break apart the field in the datagroup that has the destination. The delimiter is a vertical bar"
    set dest [getfield $destination "|" 1]
    set port [getfield $destination "|" 2]
    #log local0. "dest=$dest , port=$port"
    set name $dest
    # Determine whether the destination is a FQDN or IP address
    set ver "[catch {IP::addr $dest mask 255.255.255.255} ]"
    #If the destination is an IP address, send it directly
    if {$ver == 0} {
      log local0. "dest is IP address, skipping name lookup (node: $dest $port)"
      node $dest $port
      return
    }

    # If it is an FQDN, do a DNS lookup for the IP address
    set recordsTable "$name-$key"
    set recordsTTL   "$name-$key-ttl"

    if { $static::drop_tables == 1 } {
      table delete -subtable $recordsTable -all
      table delete $recordsTTL
    }

    #log local0. "(DEBUG) recordsTable: $recordsTable ([table keys -subtable $recordsTable -count]), recordsTTL: $recordsTTL ([table timeout -remaining $recordsTTL])"
    if { [table keys -subtable $recordsTable -count] == 0 || [table timeout -remaining $recordsTTL] < 10 } {
      #log local0. "(DEBUG) Performing DNS lookup"

      set result [RESOLVER::name_lookup "/Common/proxyDNSresolver-retry" $name a]

      # Set TTL value for table lifetime
      set ttl [lindex [lindex [DNSMSG::section $result answer] 0] 1]
      if { $ttl < $static::proxy_min_ttl } {
        set ttl $static::proxy_min_ttl
      }
      elseif { $ttl > $static::proxy_max_ttl } {
        set ttl $static::proxy_max_ttl
      }
      #log local0. "(DEBUG) TTL: $ttl"

      #log local0. "(DEBUG) Initial response: [lindex [DNSMSG::section $result answer] 0]"
      if { [lindex [DNSMSG::section $result answer] 0] != "" } {
        # Add A records to $records list and add to subtable
        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "A" } {
            table set -subtable $recordsTable [DNSMSG::record $rr rdata] 1 $ttl $ttl
          }
        }
      }
      else {
        set result [RESOLVER::name_lookup "/Common/proxyDNSresolver-retry" $name any]
        # See if this is an MX record or not
        if { [DNSMSG::record [lindex [DNSMSG::section $result answer] 0] type] == "MX" } {
          #log local0. "(DEBUG) Found record type: MX"
          # Create a list of hosts to lookup
          foreach rr [DNSMSG::section $result answer] {
            lappend mx_records "[lindex [DNSMSG::record $rr rdata] 1] [lindex [DNSMSG::record $rr rdata] 0]"
          }
          # Sort MX records by MX priority
          set name_records [lsort -index 1 $mx_records]
          #log local0. "(DEBUG) Name records: $name_records"
        }
        else {
          # Create a list of hosts to lookup
          foreach rr [DNSMSG::section $result answer] {
            lappend name_records "[DNSMSG::record $rr rdata]"
          }
        }
        # We have the names, now lookup the addresses and add them to $records
        foreach rr $name_records {
          set newhost [lindex $rr 0]
          #log local0. "(DEBUG) newhost: $newhost"
          set result [RESOLVER::name_lookup "/Common/proxyDNSresolver-retry" $newhost a]
          set answer [DNSMSG::section $result answer]
          foreach record $answer {
            #log local0. "(DEBUG) newhost: $newhost, record: [DNSMSG::record $record rdata], type: [DNSMSG::record $record type]"
            if { [DNSMSG::record $record type] eq "A" } {
              set rdata [DNSMSG::record $record rdata]
              table set -subtable $recordsTable [DNSMSG::record $record rdata] 0 $ttl $ttl
            }
            else {
              log local0. "Skipping record type '[DNSMSG::record $record type]' ([DNSMSG::record $record rdata])"
            }
          }
        }
      }
      if { [table keys -subtable $recordsTable -count] == 0 } {
        log local0. "No DNS records for $name (Link ID: $LINKID1)"
        reject
        set rejected 1
        return
      }
      else {
        # Create our freshness key
        table set $recordsTTL $ttl $ttl $ttl
      }
    }

    # Create sorted list to use an entry that hasn't already been used (if possible)
    set records {}
    foreach addr [table keys -notouch -subtable $recordsTable] {
      lappend records "$addr [table timeout -subtable $recordsTable -remaining $addr]"
    }
    # Sort list by key timeout
    set sorted [lsort -index 1 $records]

    # Select first entry in list
    set ips [lindex [lindex $sorted 0] 0]

    #log local0. "(DEBUG) Selected address: $ips"
    #log local0. "(DEBUG) All records: [join $sorted ", "] "

    # Forward the connection to the server on the correct port
    log local0. "node $ips $port"
    node $ips $port
  }
}

when CLIENT_DATA {
  log local0. "CLIENT_DATA (500)"

  # Check permission if still unknown
  if { $status == "unknown" } {
    if { [info exists LINKID1] } {
      set idlist [class match -value $key equals dstPortToLinkidDG]
      if { $idlist contains $LINKID1 } {
        set status "allow"
        set reason "All checks passed"
      } elseif { $idlist eq "all" } {
      set status "allow"
      set reason "Port $key is globally allowed"
      } else {
        set status "reject"
        set reason "LINKID $LINKID1 is not allowed to connect to Port [TCP::local_port]"
      }
    } else {
      set status "reject"
      set reason "No LinkID in request"
    }
  }
  if { $status eq "reject" } {
    log local0. "F5-REJECT LinkID: $LINKID1, srcIP: $v2_sourceAddress, initialDstPort: $key, finalDst: $ips, finalPort: $port, Reason: $reason"
    reject
  } else {
    log local0. "F5-ALLOW LinkID: $LINKID1, srcIP: $v2_sourceAddress, initialDstPort: $key, finalDst: $ips, finalPort: $port Reason: $reason"
    log local0. "node $ips $port"
    node $ips $port
    TCP::release
  }
}

when SERVER_CONNECTED {
  # Don't retry if the client an IP address was provided rather than an FQDN
  if { $ver == 0 } { 
    return
  }
  # reset the key timeout value so it appears at the bottom of the sorted list
  #log local0. "(DEBUG) Updating timeout for $ips"
  table incr -subtable $recordsTable $ips
}

when LB_FAILED {
  log local0. "LB_FAILED (Link ID: $LINKID1, Host: $ips)"
  # Don't retry if the client an IP address was provided rather than an FQDN
  if { $ver == 0 } {
    log local0. "LB_FAILED ($LINKID1) Failed to connect to $ips, not retrying"
    return
  }

  # Remove the unresponsive address from the subtable
  log local0. "Server: $ips unresponsive - removing from records list (Link ID: $LINKID1)"
  table delete -subtable $recordsTable $ips

  # Select next entry in list
  set records {}
  foreach addr [table keys -notouch -subtable $recordsTable] {
    lappend records "$addr [table timeout -subtable $recordsTable -remaining $addr]"
  }

  if { [llength $records] != 0 } {
    #set sorted [lsort -index $records 1]
    foreach pair [lsort -index 1 $records] {
      set addr [lindex $pair 0]
      log local0. "(DEBUG) Found Host: $addr"
      if { [table lookup -notouch -subtable $recordsTable $addr] != "" } {
        log local0. "(DEBUG) Using Host: $addr"
        set ips $addr
        break
      }
    }
  }
  else {
    log local0. "Link ID: $LINKID1 - No hosts available for $name"
  }

  log local0. "Trying IP: (LinkID: $LINKID1) Host: $ips:$port"
  #log local0. "node $ips $port"
  LB::reselect node $ips $port
}
}

ltm rule bastionIrule {
when CLIENT_ACCEPTED priority 400 {
  set max_retries 4
  set cur_retry 0
  set status "unknown"
  set reason "default"
  #log local0. "priority 400 client_accepted, tcp local port is [TCP::local_port]"
  # Create a variable called key which has the destination TCP port. This will serve as the lookup key into the datagroup.
  set key "[TCP::local_port]"
  #log local0. "Set the lookup key to $key"
  # Create a variable called destination which has the extracted destination from the datagroup
  set destination [class match -value $key equals mapPortToIPport]
  #log local0. "Value pulled from Datagroup mapPortToIPport = [class match -value $key equals mapPortToIPport]"
  # Check to see if the response from the datagroup was empty, if so,set a variable so the other iRule can log appropriately
  # The BIG-IP datagroup does not have an entry for this port
  if { $destination eq "" } {
    set status "reject"
    set reason "Datagroup mapPortToIPport did not have an entry for port $key"
    return
  } else {
    # Break apart the field in the datagroup that has the destination. The delimiter is 2 vertical bars"
    set dest [getfield $destination "|" 1]
    set port [getfield $destination "|" 2]
    #log local0. "dest=$dest , port=$port"
    set name $dest
    # Determine whether the destination is a FQDN or IP address
    set ver "[catch {IP::addr $dest mask 255.255.255.255} ]"
    #If the destination is an IP address, send it directly
    if {$ver eq 0} {
      return
    }

    # If it is an FQDN, do a DNS lookup for the IP address
    # Uncomment the following line for debugging
    #table delete -subtable $name -all
    if { [table lookup -notouch -subtable $name records] == "" } {
      # No subtable for this name exists, look it up
      set records {}
      set result [RESOLVER::name_lookup "/Common/proxyDNSresolver" $name a]
      if { [RESOLVER::summarize $result] != "" } {
        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "A" } {
            lappend records [DNSMSG::record $rr rdata]
          }
        }
      }
      else {
        set result [RESOLVER::name_lookup "/Common/proxyDNSresolver" $name any]
        log local0. "$name additional records: [DNSMSG::section $result additional]"

        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "MX" } {
            set newhost [lindex [DNSMSG::record $rr rdata] 1]
          }
          else {
            set newhost [DNSMSG::record $rr rdata]
            log local0. "newhost: $newhost"
          }
          set result [RESOLVER::name_lookup "/Common/proxyDNSresolver" $newhost a]
          set answer [DNSMSG::section $result answer]

          foreach record $answer {
            if { [DNSMSG::record $record type] == "A" } {
              set rdata [DNSMSG::record $record rdata]
              lappend records $rdata
            }
            else {
              log local0. "Skipping record type '[DNSMSG::record $record type]' ([DNSMSG::record $record rdata])"
            }
          }
        }
      }

      if { [llength $records] != 0 } {
        # create a table using the hostname to contain the response
        set ttl [lindex [lindex [RESOLVER::summarize $result] 0] 1]
        if { $ttl < 30 } {
          set ttl 30
        }
        table set -subtable $name records $records $ttl
        table set -subtable $name cur 0 $ttl
        table set -subtable $name total [llength [table lookup -notouch -subtable $name records]] $ttl
      }
      else {
        log local0. "No DNS records for $name"
        reject
      }
    }
    else {
      set result [table lookup -notouch -subtable $name records]
    }

    log local0. "(DEBUG) table records: [table lookup -notouch -subtable $name records], Current entry: [table lookup -notouch -subtable $name cur], Total entries: [table lookup -notouch -subtable $name total]"
#    log local0. "(DEBUG) Current entry: [table lookup -notouch -subtable $name cur], Total entries: [table lookup -notouch -subtable $name total]"

    set ips [lindex [table lookup -notouch -subtable $name records] [table lookup -notouch -subtable $name cur]]
    if { [table incr -notouch -subtable $name cur] >= [table lookup -notouch -subtable $name total] } {
      table set -notouch -subtable $name cur 0
    }
    set ips "10.1.1.1"

    if {$ips eq ""} {
      # Input wasn't an IP address, take some default action
      set status "reject"
      set reason "No DNS response received for $dest"
    } else {
      # Send the traffic on its' way to the correct server on the correct port
      set dest $ips
      #log local0. "The destination was an FQDN, passing along ip=$dest port=$port"
    }
  }
}

when CLIENT_DATA priority 700 {
  #log local0. "Linkid is $LINKID1"
  if { [info exists LINKID1] } {
    set idlist [class match -value $key equals dstPortToLinkidDG]
    if { $idlist contains $LINKID1 } {
      set status "allow"
      set reason "All checks passed"
    } elseif { $idlist eq "all" } {
      set status "allow"
      set reason "Port $key is globally allowed"
    } else {
      set status "reject"
      set reason "LINKID $LINKID1 is not allowed to connect to Port [TCP::local_port]"
      }
  } else {
    set status "reject"
    set reason "No LinkID in request"
  }
  if { $status eq "reject" } {
    log local0. "F5-REJECT LinkID: $LINKID1, srcIP: $v2_sourceAddress, initialDstPort: $key, finalDst: $dest, finalPort: $port, Reason: $reason"
    reject
  } else {
  #log local0. "F5-ALLOW LinkID: $LINKID1, srcIP: $v2_sourceAddress, initialDstPort: $key, finalDst: $dest, finalPort: $port Reason: $reason"

  #log local0. "node $dest $port"
  node $dest $port
  TCP::release
  }
}

when LB_FAILED {
  if {[incr cur_retry] >= $max_retries } {
    log local0. "Maximum retries exceeded, closing client connection (retry # [table lookup -notouch -subtable $name retry], max: $max_retries)"
    reject
  }

  log local0. "LB_FAILED ($name Current entry: [table lookup -notouch -subtable $name cur], Total entries: [table lookup -notouch -subtable $name total])"

  set ips [lindex [table lookup -notouch -subtable $name records] [table lookup -notouch -subtable $name cur]]
  if { [table incr -notouch -subtable $name cur] >= [table lookup -notouch -subtable $name total] } {
    table set -notouch -subtable $name cur 0
  }
  log local0. "node $ips $port"
  node $ips $port
  LB::reselect
}
}

ltm rule hostIDCheck {
when HTTP_PROXY_REQUEST {
  set dest [getfield [HTTP::host] ":" 1]
  set port [getfield [HTTP::host] ":" 2]
  set name $dest
  set cur_retry 0
  set max_retries 4

    #table delete -subtable $name -all
    if { [table lookup -notouch -subtable $name records] == "" } {
      # No subtable for this name exists, look it up
      set records {}
      set result [RESOLVER::name_lookup "/Common/proxyDNSresolver" $name a]
      if { [RESOLVER::summarize $result] != "" } {
        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "A" } {
            lappend records [DNSMSG::record $rr rdata]
          }
        }
      }
      else {
        set result [RESOLVER::name_lookup "/Common/proxyDNSresolver" $name any]
        log local0. "$name additional records: [DNSMSG::section $result additional]"

        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "MX" } {
            set newhost [lindex [DNSMSG::record $rr rdata] 1]
          }
          else {
            set newhost [DNSMSG::record $rr rdata]
            log local0. "newhost: $newhost"
          }
          set result [RESOLVER::name_lookup "/Common/proxyDNSresolver" $newhost a]
          set answer [DNSMSG::section $result answer]

          foreach record $answer {
            if { [DNSMSG::record $record type] == "A" } {
              set rdata [DNSMSG::record $record rdata]
              lappend records $rdata
            }
            else {
              log local0. "Skipping record type '[DNSMSG::record $record type]' ([DNSMSG::record $record rdata])"
            }
          }
        }
      }

      if { [llength $records] != 0 } {
        # create a table using the hostname to contain the response
        set ttl [lindex [lindex [RESOLVER::summarize $result] 0] 1]
        if { $ttl < 30 } {
          set ttl 30
        }
        table set -subtable $name records $records $ttl
        table set -subtable $name cur 0 $ttl
        table set -subtable $name total [llength [table lookup -notouch -subtable $name records]] $ttl
      }
      else {
        log local0. "No DNS records for $name"
        reject
      }
    }
    else {
      set result [table lookup -notouch -subtable $name records]
    }

    log local0. "(DEBUG) table records: [table lookup -notouch -subtable $name records], Current entry: [table lookup -notouch -subtable $name cur], Total entries: [table lookup -notouch -subtable $name total]"
#    log local0. "(DEBUG) Current entry: [table lookup -notouch -subtable $name cur], Total entries: [table lookup -notouch -subtable $name total]"

    set ips [lindex [table lookup -notouch -subtable $name records] [table lookup -notouch -subtable $name cur]]
    if { [table incr -notouch -subtable $name cur] >= [table lookup -notouch -subtable $name total] } {
      table set -notouch -subtable $name cur 0
    }
    set ips "10.1.1.1"
    HTTP::uri "$ips:$port"
}

when LB_FAILED {
  if {[incr cur_retry] >= $max_retries } {
    log local0. "Maximum retries exceeded, closing client connection (retry # [table lookup -notouch -subtable $name retry], max: $max_retries)"
    reject
  }

  log local0. "LB_FAILED ($name Current entry: [table lookup -notouch -subtable $name cur], Total entries: [table lookup -notouch -subtable $name total])"

  set ips [lindex [table lookup -notouch -subtable $name records] [table lookup -notouch -subtable $name cur]]
  if { [table incr -notouch -subtable $name cur] >= [table lookup -notouch -subtable $name total] } {
    table set -notouch -subtable $name cur 0
  }

  log local0. "HTTP::uri $ips:$port"
  HTTP::uri "$ips:$port"
  virtual webproxyForwarder $ips $port
  LB::reselect
}
}

ltm rule /Common/hostIDCheck-retry {
when RULE_INIT {
  set static::proxy_min_ttl 30
  set static::proxy_max_ttl 300
  set static::drop_tables 0
}

when HTTP_PROXY_REQUEST priority 500 {
  #log local0. "(HTTP_PROXY_REQUEST priority 500)"
  set rejected    0
  set proxyhost [HTTP::host]
  if { $proxyhost == "" || $proxyhost ends_with ":3128" } {
    set proxyhost [HTTP::uri]
  }
  if { $proxyhost == "" } {
    log "proxyhost not populated: ($proxyhost)"
  }
  set fqdn [getfield $proxyhost ":" 1]
  set port [getfield $proxyhost ":" 2]
  if { $port == "" } {
    set port 80
  }
  #log local0. "Destination: $fqdn:$port"

  if { [class match $fqdn ends_with globalHostAllowDG] } {
    log local0. "F5-ALLOW: LinkID: $LINKID1, $fqdn globally allowed"
    return
  }

  if { [info exists LINKID1] } {
    set hostlist [class match -value $LINKID1 equals linkIDhostsDG ]
    if { $hostlist eq "all"} { return }

    set hostarray [split $hostlist ","]
    #log local0. "F5-DEBUG LinkID $LINKID1 allowed to list \[$hostarray\]"
    #Check to see if host is in the allowed list for the LinkID
    if { [lsearch $hostarray $fqdn] > -1 } {
      log local0. "F5-ALLOW  LinkID: $LINKID1, srcIP: $v2_sourceAddress allowed to connect to $fqdn"
      return
    } else {
      HTTP::respond 403 content " Error Code: 402 -- F5-REJECT LinkID: $LINKID1, srcIP: $v2_sourceAddress blocked to $fqdn \r \n"
      log local0. "F5-REJECT LinkID: $LINKID1, srcIP: $v2_sourceAddress blocked to $fqdn"
      reject
      set rejected 1
    }
  } else {
    log local0. "F5-REJECT No link ID found while connecting to $fqdn"
    HTTP::respond 403 content " Error Code: 403 -- F5-REJECT No Link ID found \r \n"
    reject
    set rejected 1
  }
}

when HTTP_PROXY_REQUEST priority 800 {
  #log local0. "HTTP_PROXY_REQUEST priority 800"

  if { $rejected == 1 } {
    #log local0. "Connection rejected, returning (link: $LINKID1 -> $fqdn)"
    return
  }
  # Determine whether the destination is a FQDN or IP address
  set ver "[catch {IP::addr $fqdn mask 255.255.255.255} ]"

  if { $ver eq 0 } {
    set ips $fqdn
    set name ""
  }
  else {
    set name $fqdn
  }
  set recordsTable "$name-$LINKID1"
  set recordsTTL "$name-$LINKID1-ttl"

  if { $static::drop_tables == 1 } {
    table delete -subtable $recordsTable -all
    table delete $recordsTTL
  }

  # Only perform DNS lookup if destination is an FQDN
  if { $ver != 0 } {

    if { [set tcount [table keys -subtable $recordsTable -count]] eq "" } { set tcount 0 }
    if { [set ttlrec [table lookup $recordsTTL]] eq "" } { set ttlrec 0 } 
    if { [set ttltimeout [table timeout -remaining $recordsTTL]] eq "" }  { set ttltimeout 0 }
    if { $tcount == 0 || $ttlrec < 10 || $ttltimeout < 10 } {
      #log local0. "(DEBUG) Performing DNS lookup"

      # No subtable for this name exists, look it up
      set result [RESOLVER::name_lookup "/Common/proxyDNSresolver-retry" $name a]

      if { [lindex [DNSMSG::section $result answer] 0] != "" } {
        # Set TTL value for table lifetime
        set ttl [lindex [lindex [DNSMSG::section $result answer] 0] 1]
        if { $ttl < $static::proxy_min_ttl } {
          set ttl $static::proxy_min_ttl
        }
        elseif { $ttl > $static::proxy_max_ttl } {
          set ttl $static::proxy_max_ttl
        }

        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "A" } {
            table set -subtable $recordsTable [DNSMSG::record $rr rdata] 1 $ttl $ttl
          }
        }
      }
      else {
        set result [RESOLVER::name_lookup "/Common/proxyDNSresolver-retry" $name any]
        log local0. "$name additional records: [DNSMSG::section $result additional]"

        foreach rr [DNSMSG::section $result answer] {
          if { [DNSMSG::record $rr type] == "MX" } {
            set newhost [lindex [DNSMSG::record $rr rdata] 1]
          }
          else {
            set newhost [DNSMSG::record $rr rdata]
            log local0. "newhost: $newhost"
          }
          set result [RESOLVER::name_lookup "/Common/proxyDNSresolver-retry" $newhost a]
          set answer [DNSMSG::section $result answer]

          foreach record $answer {
            if { [DNSMSG::record $record type] == "A" } {
              set rdata [DNSMSG::record $record rdata]
              table set -subtable $recordsTable $rdata 0 $ttl $ttl
            }
            else {
              log local0. "Skipping record type '[DNSMSG::record $record type]' ([DNSMSG::record $record rdata])"
            }

          }
        }
      }

      if { [table keys -subtable $recordsTable -count] == 0 } {
        log local0. "No DNS records for $name (Link ID: $LINKID1)"
        reject
        set rejected 1
        return
      }
      else {
        # Create our freshness key
        # This sets the value of the table, the timeout, and the lifetime all to the TTL value
        # table set <name> <value> <timeout> <lifetime>
        table set $recordsTTL $ttl $ttl $ttl
      }
    }
  }

  set records {}
  foreach addr [table keys -notouch -subtable $recordsTable] {
    lappend records "$addr [table lookup -subtable $recordsTable $addr]"
  }
  # Sort list by key timeout
  set sorted [lsort -index 1 $records]

  # Select first entry in list
  set ips [lindex [lindex $sorted 0] 0]

  #log local0. "(DEBUG) Selected address: $ips"
  #log local0. "(DEBUG) All records: [join $sorted ", "] "

  if { [HTTP::query] != "" } {
    set uri "[HTTP::path]?[HTTP::query]"
  }
  else {
    set uri "[HTTP::path]"
  }

  #log local0. "HTTP::uri $ips:$port$uri"
  HTTP::uri "$ips:$port$uri"
  virtual webproxyForwarder $ips $port
}

when SERVER_CONNECTED {
  #log local0. "SERVER_CONNECTED"
  if { $ver == 0 } {
    return
  }

  # reset the key timeout value so it appears at the bottom of the sorted list
  # log local0. "(DEBUG) Updating timeout for $ips"
  table incr -subtable $recordsTable $ips
}

when LB_FAILED {
  # Don't retry if the client an IP address was provided rather than an FQDN
  if { $ver == 0 } {
    log local0. "LB_FAILED: LinkID: $LINKID1 Connection to $ips failed, not retrying"
    return
  }

  if {[table keys -subtable $recordsTable -count] eq "" || [table keys -subtable $recordsTable -count] < 2 } {
    log local0. "LB_FAILED: LinkID: $LINKID1 Connection to $fqdn-$ips failed, not retrying"
    table set $recordsTTL 0
    return
  }

  log local0. "LB_FAILED (Link ID: $LINKID1, Host: $fqdn-$ips)"

  # Remove the unresponsive address from the subtable
  log local0. "Server: $fqdn-$ips unresponsive - removing from records list (Link ID: $LINKID1)"
  table delete -subtable $recordsTable $ips

  # Select next entry in list
  set records {}
  foreach addr [table keys -notouch -subtable $recordsTable] {
    lappend records "$addr [table lookup -subtable $recordsTable $addr]"
  }

  if { [llength $records] != 0 } {
    #set sorted [lsort -index $records 1]
    foreach pair [lsort -index 1 $records] {
      set addr [lindex $pair 0]
      log local0. "(DEBUG) Found Host: $addr"
      if { [table lookup -notouch -subtable $recordsTable $addr] != "" } {
        log local0. "(DEBUG) Using Host: $addr"
        set ips $addr
        break
      }
    }
  }
  else {
    log local0. "Link ID: $LINKID1 - No hosts available for $name"
  }

  log local0. "(DEBUG) Retrying with new host: $ips:$port$uri"
  HTTP::uri "$ips:$port$uri"
  virtual webproxyForwarder $ips $port
  LB::reselect
}
}

ltm rule /Common/proxy_v2_handler {
#Set priority to 100
priority 100
#PROXY Protocol Receiver iRule
when RULE_INIT {
    set static::allowProxyV1 1
    set static::allowProxyV2 1
    set static::allowNoProxy 0
    set static::DEBUG 0

    # Azure link-id TLV:  238
    # AWS link-id TLV:    234
    # GCP link-id TLV:    234
    set static::cloud "aws"

    if { $static::cloud == "gcp" || $static::cloud == "azure" } {
      set static::skip 28
    }

    if { $static::cloud == "aws" } {
      set static::skip 28
    }
}
when CLIENT_ACCEPTED {
    log local0. "CLIENT ACCEPTED (100)"
    set status "unknown"
    TCP::collect 28
}
when CLIENT_DATA {
    log local0. "CLIENT_DATA (100)"
    binary scan [TCP::payload 12] H* v2_protocol_sig
    if { $static::DEBUG } { log local0. "Protocol Signature: $v2_protocol_sig" }
    if {$static::allowProxyV1 && [TCP::payload 0 5] eq "PROXY"} {
        set proxy_string [TCP::payload]
        set proxy_string_length [expr {[string first "\r" [TCP::payload]] + 2}]
        scan $proxy_string {PROXY TCP%s%s%s%s%s} tcpver srcaddr dstaddr srcport dstport
        log "Proxy Protocol v1 conn from [IP::client_addr]:[TCP::client_port] for an IPv$tcpver stream from Src: $srcaddr:$srcport to Dst: $dstaddr:$dstport"
        TCP::payload replace 0 $proxy_string_length ""
    } elseif {$static::allowProxyV2 && $v2_protocol_sig eq "0d0a0d0a000d0a515549540a"}{
        binary scan [TCP::payload] @12H* v2_proxyheaderremainder
        binary scan [TCP::payload] @12H2H* v2_verCommand v2_remainder
        if { $static::DEBUG } { log local0. "v2_verCommand: $v2_verCommand" }
        if { $v2_verCommand == 21 } {
            binary scan [TCP::payload] @13H2 v2_addressFamilyTransportProtocol
            if { $static::DEBUG } { log "v2_addressFamilyTransportProtocol: $v2_addressFamilyTransportProtocol" }
            if { $v2_addressFamilyTransportProtocol == 11 } {
                # Get the total length of the PP2 header so we can remove it later
                binary scan [TCP::payload] @14S pp2DataLen
                set pp2HdrTotLen [expr {$pp2DataLen + 16}]
                binary scan [TCP::payload] H* dbg_pp2Hdr
                #This is where we have processed everything through dest port
                binary scan [TCP::payload] @16ccccccccSS v2_sourceAddress1 v2_sourceAddress2 v2_sourceAddress3 v2_sourceAddress4 v2_destAddress1 v2_destAddress2 v2_destAddress3 v2_destAddress4 v2_sourcePort1 v2_destPort1
                set v2_sourceAddress "[expr {$v2_sourceAddress1 & 0xff}].[expr {$v2_sourceAddress2 & 0xff}].[expr {$v2_sourceAddress3 & 0xff}].[expr {$v2_sourceAddress4 & 0xff}]"
                set v2_destAddress "[expr {$v2_destAddress1 & 0xff}].[expr {$v2_destAddress2 & 0xff}].[expr {$v2_destAddress3 & 0xff}].[expr {$v2_destAddress4 & 0xff}]"
                set v2_sourcePort [expr {$v2_sourcePort1 & 0xffff}]
                set v2_destPort [expr {$v2_destPort1 & 0xffff}]
                if { $static::DEBUG } {
                  log local0. "Proxy Protocol v2 conn from [IP::client_addr]:[TCP::client_port] for an IPv4 Stream from Src: $v2_sourceAddress:$v2_sourcePort to Dst: $v2_destAddress:$v2_destPort"
                }
                set pp2Hdr [string range [TCP::payload] $static::skip end]

                while { [string length $pp2Hdr] > 4 } {
                    #Scan the PP2type, length - PP2type is 8 bit, length is 16 bits
                    binary scan $pp2Hdr cS PP2TYPE VALLENGTH
                    set PP2TYPE [ expr {$PP2TYPE & 0xff}]
                    set VALLENGTH [ expr {$VALLENGTH & 0xffff}]

                    if { $PP2TYPE != 234 && $PP2TYPE != 238 } {
                      # Skip this TLV
                      if { $static::DEBUG } { log local0. "Found PP2 type: $PP2TYPE. Skipping." }
                      set pp2Hdr [string range $pp2Hdr [expr { 3 + $VALLENGTH }] end]
                      continue
                    }

                    ## GCP header
                    if { $PP2TYPE == 234 && $static::cloud == "gcp" } {
                      if {$static::DEBUG} {
                        log local0. "Processing GCP PP2 header. PP2 type: $PP2TYPE"
                      }
                      binary scan $pp2Hdr @3W linkid_raw
                      set LINKID1 [expr { $linkid_raw & 0xffffffffffffffff } ]
                      if { $static::DEBUG } {
                        log local0. "GCP Link ID: $LINKID1"
                      }
                    }
                    ## AWS header
                    if { $PP2TYPE == 234 && $static::cloud == "aws" } {
                      set tlvLen [expr {$VALLENGTH - 1}]
                      if {$static::DEBUG} {
                        log local0. "Processing AWS PP2 header. PP2 type: $PP2TYPE"
                      }
                      binary scan $pp2Hdr @3xa${tlvLen} LINKID1
                      if { $static::DEBUG } {
                        log local0. "AWS Link ID: $LINKID1"
                      }
                    }
                    ## Azure header
                    if { $PP2TYPE == 238 && $static::cloud == "azure" } {
                      if {$static::DEBUG} {
                        log local0. "Processing Azure PP2 header. PP2 type: $PP2TYPE"
                      }
                      binary scan $pp2Hdr @3xi linkid_raw
                      set LINKID1 [expr { $linkid_raw & 0xffffffff } ]
                      if { $static::DEBUG } {
                        log local0. "Azure Link ID: $LINKID1"
                      }
                    }
                    # removed processed portion of PP2 header
                    set pp2Hdr [string range $pp2Hdr [expr { 3 + $VALLENGTH }] end]
                }

                if {$static::DEBUG} {log "PP2TYPE: $PP2TYPE, VALLENGTH: $VALLENGTH, $LINKID1: $LINKID1"}

                # Remove the PP2 header from the TCP payload
                TCP::payload replace 0 $pp2HdrTotLen ""
                if {$static::DEBUG} {log "Payload removed to byte $pp2HdrTotLen"}

                #log local0. "Calling TCP::release"
                #TCP::release

            } elseif {$v2_addressFamilyTransportProtocol == 21} {
                log "Address family 21 (IPv6) not supported in this environment"
            } else {
                log "F5-REJECT LinkID: $LINKID1 v2_proxy conn from [IP::client_addr]:[TCP::client_port] - possible unknown/malformed transportProtocol or addressFamily"
                reject
            }
        } elseif {$v2_verCommand == 20}{
            log "Proxy Protocol v2 and LOCAL command from [IP::client_addr]:[TCP::client_port]; currently unhandled; connection reset"
            reject
        } else {
            log "Proxy Protocol Protocol Signature Detected from [IP::client_addr]:[TCP::client_port] but protocol version and command not legal; connection reset"
            reject
        }
    } elseif {$static::allowNoProxy} {
        set LINKID1 "NOLINKID"
        log "Connection from [IP::client_addr]:[TCP::client_port] allowed despite lack of PROXY protocol header"
    } else {
        reject
        log "Connection rejected from [IP::client_addr]:[TCP::client_port] due to lack of PROXY protocol header"
    }
    #TCP::release
}

when CLIENT_DATA priority 800 {
  log local0. "CLIENT_DATA (800)"
  log local0. "Calling TCP::release"
  TCP::release
}
}


ltm rule webapi_forwarder {
when CLIENT_ACCEPTED {
  log local0. "CLIENT_ACCEPTED - Dest: [IP::local_addr]:[TCP::local_port]"
}
}

ltm profile http /Common/http_proxy {
  app-service none
  defaults-from /Common/http-explicit
  explicit-proxy {
    bad-request-message "BAD REQUEST FROM CLIENT"
    bad-response-message "BAD RESPONSE FROM REMOTE HOST"
    connect-error-message "CONNECTION FAILED"
    dns-error-message "DNS LOOKUP FAILED"
    dns-resolver /Common/proxyDNSresolver
    tunnel-name /Common/proxy_tunnel
  }
  proxy-type explicit
}

ltm profile http http_proxy-retry {
    app-service none
    defaults-from http-explicit
    explicit-proxy {
        bad-request-message "BAD REQUEST FROM CLIENT"
        bad-response-message "BAD RESPONSE FROM REMOTE HOST"
        connect-error-message "CONNECTION FAILED"
        dns-error-message "DNS LOOKUP FAILED"
        dns-resolver proxyDNSresolver-retry
        tunnel-name proxy_tunnel
    }
    proxy-type explicit
}


ltm profile tcp BBRprof {
    app-service none
    auto-proxy-buffer-size enabled
    auto-receive-window-size enabled
    auto-send-buffer-size enabled
    congestion-control bbr
    defaults-from tcp
    description none
    hardware-syn-cookie disabled
    init-cwnd 16
    init-rwnd 16
    max-segment-size 0
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    push-flag auto
    receive-window-size 131072
    send-buffer-size 262144
    syn-max-retrans 3
    syn-rto-base 1000
    tcp-options none
}

ltm profile tcp BBRprof_orig {
    abc enabled
    ack-on-push enabled
    app-service none
    auto-proxy-buffer-size enabled
    auto-receive-window-size enabled
    auto-send-buffer-size enabled
    close-wait-timeout 5
    cmetrics-cache enabled
    cmetrics-cache-timeout 0
    congestion-control bbr
    deferred-accept disabled
    delay-window-control disabled
    delayed-acks enabled
    description none
    dsack disabled
    early-retransmit enabled
    ecn enabled
    enhanced-loss-recovery enabled
    fast-open enabled
    fast-open-cookie-expiration 21600
    fin-wait-2-timeout 300
    fin-wait-timeout 5
    idle-timeout 300
    init-cwnd 16
    init-rwnd 16
    ip-df-mode pmtu
    ip-tos-to-client 0
    ip-ttl-mode proxy
    ip-ttl-v4 255
    ip-ttl-v6 64
    keep-alive-interval 1800
    limited-transmit enabled
    link-qos-to-client 0
    max-retrans 8
    max-segment-size 0
    md5-signature disabled
    minimum-rto 1000
    mptcp disabled
    mptcp-csum disabled
    mptcp-csum-verify disabled
    mptcp-fallback reset
    mptcp-fastjoin disabled
    mptcp-idle-timeout 300
    mptcp-join-max 5
    mptcp-makeafterbreak disabled
    mptcp-nojoindssack disabled
    mptcp-rtomax 5
    mptcp-rxmitmin 1000
    mptcp-subflowmax 6
    mptcp-timeout 3600
    nagle auto
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    proxy-mss enabled
    proxy-options disabled
    push-flag auto
    rate-pace enabled
    rate-pace-max-rate 0
    receive-window-size 131072
    reset-on-timeout enabled
    rexmt-thresh 3
    selective-acks enabled
    selective-nack disabled
    send-buffer-size 262144
    slow-start enabled
    syn-cookie-enable enabled
    syn-cookie-whitelist disabled
    syn-max-retrans 3
    syn-rto-base 3000
    tail-loss-probe enabled
    tcp-options none
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
    verified-accept disabled
    zero-window-timeout 20000
}



net dns-resolver proxyDNSresolver {
    answer-default-zones yes
    cache-size 10bytes
    forward-zones {
        . { nameservers { 203.0.113.5:53 { } } }
        att.com { nameservers { 4.2.2.2:53 { } } }
        google.com { nameservers { 8.8.8.8:53 { } } }
    }
    randomize-query-name-case no
    route-domain 0
    use-ipv6 no
    use-tcp no
}

net dns-resolver proxyDNSresolver-retry {
    forward-zones {
        . { nameservers { 168.63.129.16:53 { } } }
        att.com { nameservers { 4.2.2.2:53 { } } }
        google.com { nameservers { 8.8.8.8:53 { } } }
    }
    route-domain 0
    use-ipv6 no
}

net tunnels tunnel proxy_tunnel { profile tcp-forward }

ltm virtual mainListener {
    destination __VS_ADDR__:0
    ip-protocol tcp
    mask 255.255.255.255
    profiles { BBRprof { } }
    rules { proxy_v2_handler bastionIRule-retry }
    source-address-translation { type automap }
    translate-address enabled
    translate-port enabled
    vlans { external }
    vlans-enabled
}

ltm virtual monitor_response {
    destination __VS_ADDR__:65000
    ip-protocol tcp
    mask 255.255.255.255
    profiles { tcp { } }
    translate-address enabled
    translate-port enabled
}

ltm virtual web_api {
    destination __VS_ADDR__:3128
    ip-protocol tcp
    mask 255.255.255.255
    profiles { BBRprof { } http_proxy-retry { } }
    rules { proxy_v2_handler hostIDCheck-retry }
    translate-address enabled
    translate-port enabled
    vlans { external }
    vlans-enabled
}

ltm virtual webproxyForwarder {
    destination 0.0.0.0:0
    ip-forward
    ip-protocol tcp
    mask any
    profiles { fastL4 { } }
    rules { webapi_forwarder }
    source-address-translation { type automap }
    translate-address disabled
    translate-port disabled
    vlans { proxy_tunnel }
    vlans-enabled
}
